import os
import re
import argparse
import numpy as np
import csv
from scipy.interpolate import interp1d
import plotly.graph_objects as go

"""
cvtest.py

** Note: This script was mostly generated by AI. It needs to be tested and validated before use.

This script performs self-convergence analysis on VisIt-style curve files.
It computes the convergence factor Q(t) for specified fields across three resolutions:
    O(4h), O(2h), and O(h).

It supports different error norms (L2, Linf, L1) and can output results to CSV files.
It also generates plots of the convergence factor over time.

Usage:
    python cvtest.py <dir4h> <dir2h> <dirh>
    - dir4h: Directory containing O(4h) resolution curve files.
    - dir2h: Directory containing O(2h) resolution curve files.
    - dirh: Directory containing O(h) resolution curve files.
    -f/--fields: Specify the fields to analyze (e.g., 'alpha', 'chi').
    --norm: Specify the error norm to use (default is L2).
    --csv: If specified, results will be saved to a CSV file.

"""

def parse_curve_file(filename, field_name):
    with open(filename, 'r') as f:
        lines = f.readlines()

    time = None
    data = {}
    current_field = None
    field_data = []

    for line in lines:
        if line.startswith('# TIME'):
            time = float(line.split()[2])
        elif line.startswith('#'):
            if current_field is not None:
                data[current_field] = np.array(field_data)
            current_field = line[1:].strip()
            field_data = []
        elif line.strip():
            x, y = map(float, line.strip().split())
            field_data.append((x, y))

    if current_field is not None:
        data[current_field] = np.array(field_data)

    if field_name not in data:
        raise ValueError(f"Field '{field_name}' not found in {filename}")

    return time, data[field_name]

def load_all_curve_data(directory, field_name):
    files = sorted(f for f in os.listdir(directory) if f.endswith('.curve'))
    data = []
    times = []

    for f in files:
        time, field_data = parse_curve_file(os.path.join(directory, f), field_name)
        times.append(time)
        data.append(field_data)

    return np.array(times), data

def compute_norm(u, norm_type):
    if norm_type == 'L2':
        return np.linalg.norm(u)
    elif norm_type == 'Linf':
        return np.max(np.abs(u))
    elif norm_type == 'L1':
        return np.sum(np.abs(u))
    else:
        raise ValueError(f"Unknown norm type: {norm_type}")

def compute_convergence(y0, y1_interp, y2_interp, norm_type):
    err1_vec = y0 - y1_interp
    err2_vec = y1_interp - y2_interp
    err1 = compute_norm(err1_vec, norm_type)
    err2 = compute_norm(err2_vec, norm_type)
    if err2 == 0 or err1 == 0:
        return np.nan, err1, err2
    return np.log2(err1 / err2), err1, err2

def interpolate_to(ref_points, source_data):
    interp_func = interp1d(source_data[:, 0], source_data[:, 1], kind='cubic', fill_value=np.nan, bounds_error=False)
    return interp_func(ref_points)

def save_to_csv(times, norms1, norms2, Q_values, field_name, output_dir='output'):
    os.makedirs(output_dir, exist_ok=True)
    csv_path = os.path.join(output_dir, f'{field_name}_convergence.csv')
    with open(csv_path, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(['Time', 'Norm_C-M', 'Norm_M-F', 'ConvergenceFactor'])
        for t, n1, n2, q in zip(times, norms1, norms2, Q_values):
            writer.writerow([t, n1, n2, q])
    print(f"Saved CSV for {field_name} to: {csv_path}")

def plot_convergence(times, Q_values, field_name):
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=times,
        y=Q_values,
        mode='lines+markers',
        name=f'Q(t) for {field_name}'
    ))
    fig.update_layout(
        title=f'Self-Convergence Factor Q(t) for Field: {field_name}',
        xaxis_title='Time',
        yaxis_title='Convergence Factor Q',
        template='plotly_white'
    )
    fig.show()

def main():
    parser = argparse.ArgumentParser(description='Self-convergence test using VisIt-style curve files.')
    parser.add_argument("dir4h", help='Directory for coarse resolution O(4h)')
    parser.add_argument('dir2h', help='Directory for medium resolution O(2h)')
    parser.add_argument('dirh', help='Directory for fine resolution O(h)')
    parser.add_argument('-f', '--fields', required=True, nargs='+', help='List of fields to analyze')
    parser.add_argument('--norm', default='L2', choices=['L2', 'Linf', 'L1'], help='Error norm to use')
    parser.add_argument('--csv', action='store_true', help='Write convergence factor and norms to CSV')

    args = parser.parse_args()

    for field in args.fields:
        print(f"\nAnalyzing field: {field}")
        dirs = [args.dir4h, args.dir2h, args.dirh]

        # Load data
        times_list = []
        data_list = []
        for d in dirs:
            times, data = load_all_curve_data(d, field)
            times_list.append(times)
            data_list.append(data)

        # Check for consistency
        if not all(len(times) == len(times_list[0]) for times in times_list):
            raise RuntimeError("Mismatch in number of time steps.")
        if not all(np.allclose(times, times_list[0]) for times in times_list):
            raise RuntimeError("Mismatch in time values.")

        times = times_list[0]
        Q_values = []
        norms1 = []
        norms2 = []

        for i in range(len(times)):
            u0 = data_list[0][i]  # coarse
            u1 = data_list[1][i]  # medium
            u2 = data_list[2][i]  # fine

            x0 = u0[:, 0]
            y0 = u0[:, 1]
            y1_interp = interpolate_to(x0, u1)
            y2_interp = interpolate_to(x0, u2)

            Q, err1, err2 = compute_convergence(y0, y1_interp, y2_interp, args.norm)
            Q_values.append(Q)
            norms1.append(err1)
            norms2.append(err2)

        plot_convergence(times, Q_values, field)

        # Report time-averaged convergence order
        valid_Q = [q for q in Q_values if not np.isnan(q)]
        if valid_Q:
            avg_Q = np.mean(valid_Q)
            print(f"Average convergence order for field '{field}' with {args.norm} norm: {avg_Q:.4f}")
        else:
            print(f"No valid convergence factors computed for field '{field}'.")

        if args.csv:
            save_to_csv(times, norms1, norms2, Q_values, field)

if __name__ == '__main__':
    main()

